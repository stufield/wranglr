% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create-kfold.R
\name{create_kfold}
\alias{create_kfold}
\alias{is.k_split}
\alias{analysis}
\alias{assessment}
\title{Create k-Fold Partitioning}
\usage{
create_kfold(data, k = 10L, repeats = 1L, breaks = NULL, ...)

is.k_split(x)

analysis(object, i = NULL)

assessment(object, i = NULL)
}
\arguments{
\item{data}{A \code{data.frame} containing the data to be subset.}

\item{k}{\code{integer(1)}. The number of partitions (folds) to create.}

\item{repeats}{\code{integer(1)}The number of times to repeat the \emph{k}-fold
partitioning.}

\item{breaks}{Stratification control. Either \code{NULL} or a \emph{named} list.
If \code{NULL}, no stratification is performed. See \code{Details}.}

\item{...}{For eventual extensibility. Parameters to be
passed to internal stratification machinery but currently limited
to a \code{depth} argument. The number of stratification bins is based on
\code{min(5, floor(n / depth))}, where \code{n = length(x)}.}

\item{x}{An \code{R} object to test.}

\item{object}{A \code{k_split} object.}

\item{i}{\code{integer(1)} or \code{NULL}. If an integer, the split corresponding
to the analysis or assessment data to be retrieved, otherwise a list of
\emph{all} data splits.}
}
\value{
A \code{k_split} object. Element \code{data} contains the original data.
Element \code{splits} is a tibble where each row of corresponds to an
individual split. The \code{split} column contains lists named either
"analysis" and "assessment" containing the indices of \code{data} to be
used for each fold and category.
Columns \code{fold} and \code{.repeat} provide fold and repeat indices for
each corresponding split.

\code{\link[=is.k_split]{is.k_split()}}: Logical. \code{TRUE} if \code{x} inherits from
class \code{k_split}.

\code{\link[=analysis]{analysis()}}: A list of data frames corresponding to
the analysis indices.

\code{\link[=assessment]{assessment()}}: A list of data frames corresponding to
the assessment indices.
}
\description{
Adaptation of the \code{rsample::vfold_cv()} function and its utilities.
Modified for simplicity and to accommodate two-level stratification.
Up to 2 levels of stratification can be specified through
the \code{breaks} parameter:
\itemize{
\item{No stratification: \code{breaks = NULL}}
\item{One level stratification: \code{breaks} is a \code{list(1)}, where
the name of the list element specifies the stratification
variable and the value of the element specifies the
stratification.}
\item{Two level stratification: \code{breaks} is a \code{list(2)}, where
the list names specify the stratification variables and the
corresponding values specify the stratification.}
}




}
\details{
For stratification variables that are factor, character, or discrete with
5 or fewer unique levels, the stratification structure should be set
to \code{NULL}. For example, if \code{status} is a binary variable,
\code{breaks = list(status = NULL)}.

If the stratification variable has more than 5 unique levels,
the stratification structure can be specified as either the
number of quantile-based stratification bins or as a numeric vector
providing the bin boundaries (must fully span the range of the
stratification variable). For example, for a continuous variable
in \verb{[0,1]}, \code{breaks = list(x = 4)} indicates stratification
into 4 bins, the boundaries of which are determined internally using

\if{html}{\out{<div class="sourceCode r">}}\preformatted{quantile(x, probs = seq(0.0, 1.0, length.out = 5))
}\if{html}{\out{</div>}}

and \code{breaks = list(x = c(0.0, 0.25, 0.75, 1.0))} specifies a 3 bin
structure: \verb{[0, 0.25]}, \verb{(0.25, 0.75]}, and \verb{(0.75, 1.0]}.
\strong{Note:} the lowest bin is \emph{always} inclusive.
}
\examples{
# no stratification
no_strat <- create_kfold(mtcars, k = 4L, repeats = 2L)

# stratification on 1 discrete variable
sample_one <- create_kfold(mtcars, k = 4L, repeats = 2L,
                           breaks = list(vs = NULL))

# stratification on 2 variables; 1 continuous + 1 discrete
sample_two <- create_kfold(mtcars, k = 4L, repeats = 2L,
                           breaks = list(gear = 4L, vs = NULL))

# retrieve analysis data for 2nd split
an_2 <- analysis(no_strat, 2L)

# retrieve all splits
an_all <- analysis(no_strat)

# retrieve assessment data for 2nd split
ass_2 <- assessment(no_strat, 2L)

# retrieve all splits
ass_all <- assessment(no_strat)
}
